"""Markdown investigation report generator.

Assembles structured reports from investigation data including:
  - Executive summary
  - Entity inventory with key properties
  - Network analysis findings
  - Timeline of events
  - Data sources and provenance
  - Confidence assessments and caveats

Output is clean Markdown suitable for:
  - Journalist review and editing
  - Conversion to PDF (via pandoc, weasyprint, etc.)
  - Import into CMS/publishing systems
  - Sharing with editors and collaborators
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any

logger = logging.getLogger(__name__)


@dataclass
class ReportSection:
    """A section of the investigation report."""
    title: str
    content: str
    level: int = 2  # Markdown heading level


@dataclass
class InvestigationReport:
    """Structured investigation data for report generation."""
    title: str
    summary: str = ""
    entities: list[dict[str, Any]] = field(default_factory=list)
    relationships: list[dict[str, Any]] = field(default_factory=list)
    graph_findings: dict[str, Any] = field(default_factory=dict)
    timeline_events: list[dict[str, Any]] = field(default_factory=list)
    data_sources: list[dict[str, str]] = field(default_factory=list)
    caveats: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)


class MarkdownReport:
    """Generate Markdown investigation reports.

    Parameters
    ----------
    include_provenance:
        Whether to include data source provenance for each finding.
    include_confidence:
        Whether to include confidence scores in findings.
    """

    def __init__(
        self,
        include_provenance: bool = True,
        include_confidence: bool = True,
    ) -> None:
        self._include_provenance = include_provenance
        self._include_confidence = include_confidence

    def generate(self, report: InvestigationReport) -> str:
        """Generate complete Markdown report."""
        sections: list[str] = []

        # Title and metadata
        sections.append(f"# {report.title}\n")
        sections.append(self._metadata_block(report))

        # Executive summary
        if report.summary:
            sections.append("## Executive Summary\n")
            sections.append(report.summary + "\n")

        # Entity inventory
        if report.entities:
            sections.append(self._entity_section(report.entities))

        # Network findings
        if report.graph_findings:
            sections.append(self._graph_findings_section(report.graph_findings))

        # Timeline
        if report.timeline_events:
            sections.append(self._timeline_section(report.timeline_events))

        # Data sources
        if report.data_sources:
            sections.append(self._sources_section(report.data_sources))

        # Caveats and limitations
        sections.append(self._caveats_section(report.caveats))

        return "\n".join(sections)

    def generate_from_engine_result(
        self,
        title: str,
        findings: dict[str, Any],
        summary: str = "",
    ) -> str:
        """Generate report from GraphEngine.investigate_entity() output.

        Convenience method that maps engine findings to InvestigationReport.
        """
        report = InvestigationReport(title=title, summary=summary)

        # Map graph summary
        graph_summary = findings.get("graph_summary", {})
        report.metadata["node_count"] = graph_summary.get("node_count", 0)
        report.metadata["edge_count"] = graph_summary.get("edge_count", 0)
        report.metadata["query"] = findings.get("query", "")

        # Map findings
        report.graph_findings = {
            "key_players": findings.get("key_players", []),
            "brokers": findings.get("brokers", []),
            "communities": findings.get("communities", []),
            "circular_ownership": findings.get("circular_ownership", []),
            "anomalies": findings.get("anomalies", []),
        }

        report.caveats = [
            "This report was generated by automated analysis. All findings should be independently verified.",
            "Network analysis identifies structural patterns â€” it does not prove wrongdoing.",
            "Data completeness depends on external source coverage and may be partial.",
        ]

        return self.generate(report)

    # -- Section generators --------------------------------------------------

    def _metadata_block(self, report: InvestigationReport) -> str:
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
        lines = [
            f"**Generated**: {now}  ",
            f"**Tool**: Emet Investigative Framework  ",
        ]
        if report.metadata.get("query"):
            lines.append(f"**Query**: {report.metadata['query']}  ")
        if report.metadata.get("node_count"):
            lines.append(
                f"**Network**: {report.metadata['node_count']} entities, "
                f"{report.metadata.get('edge_count', 0)} relationships  "
            )
        lines.append("")
        return "\n".join(lines)

    def _entity_section(self, entities: list[dict[str, Any]]) -> str:
        lines = ["## Entity Inventory\n"]

        # Group by schema
        by_schema: dict[str, list[dict]] = {}
        for entity in entities:
            schema = entity.get("schema", "Unknown")
            by_schema.setdefault(schema, []).append(entity)

        for schema, group in sorted(by_schema.items()):
            lines.append(f"### {schema} ({len(group)})\n")
            lines.append("| Name | Country | Key Details |")
            lines.append("|------|---------|-------------|")
            for entity in group[:20]:  # Cap at 20 per type
                name = entity.get("name", entity.get("id", "Unknown")[:12])
                country = entity.get("country", "â€”")
                details = self._entity_key_details(entity)
                lines.append(f"| {name} | {country} | {details} |")
            if len(group) > 20:
                lines.append(f"| ... | ... | +{len(group) - 20} more |")
            lines.append("")

        return "\n".join(lines)

    def _graph_findings_section(self, findings: dict[str, Any]) -> str:
        lines = ["## Network Analysis Findings\n"]

        # Key players
        key_players = findings.get("key_players", [])
        if key_players:
            lines.append("### Key Entities\n")
            lines.append("Entities ranked by structural importance in the network:\n")
            for i, kp in enumerate(key_players[:5], 1):
                lines.append(f"{i}. **{kp.get('name', 'Unknown')}** ({kp.get('schema', '')})")
                if kp.get("explanation"):
                    lines.append(f"   {kp['explanation']}")
            lines.append("")

        # Brokers
        brokers = findings.get("brokers", [])
        if brokers:
            lines.append("### Intermediaries / Brokers\n")
            lines.append("Entities bridging otherwise disconnected groups:\n")
            for broker in brokers[:5]:
                lines.append(f"- **{broker.get('name', 'Unknown')}**: {broker.get('explanation', '')}")
                for fu in broker.get("follow_up", [])[:2]:
                    lines.append(f"  - *Action*: {fu}")
            lines.append("")

        # Circular ownership
        cycles = findings.get("circular_ownership", [])
        if cycles:
            lines.append("### âš ï¸ Circular Ownership Detected\n")
            for cycle in cycles:
                entities_str = " â†’ ".join(cycle.get("entities", []))
                lines.append(
                    f"- **Cycle** (length {cycle.get('length', '?')}): "
                    f"{entities_str} â†’ [loop]"
                )
                lines.append(f"  Risk score: {cycle.get('risk_score', 0):.2f}")
                if cycle.get("explanation"):
                    lines.append(f"  {cycle['explanation']}")
            lines.append("")

        # Communities
        communities = findings.get("communities", [])
        if communities:
            lines.append("### Entity Clusters\n")
            for comm in communities[:5]:
                cross = " *(cross-jurisdiction)*" if comm.get("cross_jurisdiction") else ""
                lines.append(
                    f"- Cluster #{comm.get('id', '?')}: {comm.get('size', '?')} entities{cross}"
                )
                if comm.get("explanation"):
                    lines.append(f"  {comm['explanation']}")
            lines.append("")

        # Anomalies
        anomalies = findings.get("anomalies", [])
        if anomalies:
            lines.append("### Structural Anomalies\n")
            for anomaly in anomalies:
                severity_marker = {"high": "ðŸ”´", "medium": "ðŸŸ¡", "low": "ðŸ”µ"}.get(
                    anomaly.get("severity", "low"), "ðŸ”µ"
                )
                lines.append(
                    f"- {severity_marker} **{anomaly.get('type', 'Unknown').replace('_', ' ').title()}**: "
                    f"{anomaly.get('explanation', '')}"
                )
            lines.append("")

        if not any([key_players, brokers, cycles, communities, anomalies]):
            lines.append("No significant network patterns detected.\n")

        return "\n".join(lines)

    def _timeline_section(self, events: list[dict[str, Any]]) -> str:
        lines = ["## Timeline\n"]
        sorted_events = sorted(events, key=lambda e: e.get("date", ""))

        for event in sorted_events[:50]:  # Cap at 50 events
            date = event.get("date", "Unknown date")
            description = event.get("description", "")
            entity = event.get("entity_name", "")
            prefix = f"**{entity}**: " if entity else ""
            lines.append(f"- **{date}** â€” {prefix}{description}")

        if len(events) > 50:
            lines.append(f"\n*... and {len(events) - 50} more events*")
        lines.append("")
        return "\n".join(lines)

    def _sources_section(self, sources: list[dict[str, str]]) -> str:
        lines = ["## Data Sources\n"]
        has_timestamps = any(s.get("queried_at") for s in sources)
        if has_timestamps:
            lines.append("| Source | Type | Records | Queried |")
            lines.append("|--------|------|---------|---------|")
        else:
            lines.append("| Source | Type | Records |")
            lines.append("|--------|------|---------|")
        for source in sources:
            row = (
                f"| {source.get('name', 'Unknown')} | "
                f"{source.get('type', '')} | "
                f"{source.get('records', 'â€”')} |"
            )
            if has_timestamps:
                ts = source.get("queried_at", "â€”")
                if ts and ts != "â€”" and len(ts) > 10:
                    ts = ts[:16].replace("T", " ") + " UTC"
                row += f" {ts} |"
            lines.append(row)
        lines.append("")
        return "\n".join(lines)

    def _caveats_section(self, caveats: list[str]) -> str:
        lines = ["## Methodology & Limitations\n"]

        default_caveats = [
            "This report was generated by Emet, an AI-assisted investigative framework.",
            "All AI-generated findings should be independently verified by human journalists.",
            "Graph analysis identifies structural patterns â€” not evidence of wrongdoing.",
        ]

        all_caveats = caveats if caveats else default_caveats
        for caveat in all_caveats:
            lines.append(f"- {caveat}")

        lines.append("")
        return "\n".join(lines)

    @staticmethod
    def _entity_key_details(entity: dict[str, Any]) -> str:
        """Extract key details for entity table."""
        details = []
        props = entity.get("properties", entity)
        for key in ("registrationNumber", "incorporationDate", "leiCode",
                     "address", "jurisdiction"):
            vals = props.get(key, [])
            if vals:
                val = vals[0] if isinstance(vals, list) else vals
                details.append(f"{key}: {val}")
        return "; ".join(details[:3]) if details else "â€”"
